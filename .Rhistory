if(current_file[row_index, col_index] == 1){
neighbours <- c(0,0)
names(neighbours) <- c("above", "below")
# check pixels above
if(row_index < nrow(current_file)){
if(current_file[row_index + 1, col_index] == 1)
neighbours[1] <- 1
}
# check pixels below
if(row_index < nrow(current_file))
if(current_file[row_index - 1, col_index] == 1)
neighbours[2] <- 1
if(sum(neighbours) == 0)
num_no_vert_neighbours <- num_no_vert_neighbours + 1
}
}
}
return(num_no_vert_neighbours)
}
connected_areas <- function(current_file){
}
eyes <- function(current_file){
}
# for custom I think I should check for enclosed area.
# this would allow me to distinguish between letters
# and exclude an image from being a smliey face or some of the
# letters
custom <- function(current_file){
}
for(current_index in 1:length(data_folder))
{
current_file_name <- data_folder[current_index]
current_file_path <- paste(folder_path, current_file_name, sep = "")
current_file <- as.matrix(read.table(file = current_file_path, header = F, sep = ","))
calculated_features = matrix(ncol = 18, nrow = 1)
colnames(calculated_features) <- c("Label", "Index", "nr_pix", "rows_with_1", "cols_with_1",
"rows_with_3p", "cols_with_3p", "aspect ratio", "neigh_1",
"no_neigh_above","no_neigh_below","no_neigh_left","no_neigh_right",
"no_neigh_horiz", "no_neigh_vert","connected_areas","eyes","custom")
# rast1 <- raster(current_file)
# clump1 <- clump(rast1, directions=4)
# print(clump1)
calculated_features[1,1] <- getFileLabel(current_file_name) # works
calculated_features[1,2] <- getIndex(current_file_name) # works
calculated_features[1,3] <- nr_pix(current_file) # works
calculated_features[1,4] <- rows_with_1(current_file) # works
calculated_features[1,5] <- cols_with_1(current_file) # works
calculated_features[1,6] <- rows_with_3p(current_file) # works
calculated_features[1,7] <- cols_with_3p(current_file) # works
calculated_features[1,8] <- aspect_ratio(current_file) # works
calculated_features[1,9] <- neigh_1(current_file) # not working, needs testing
calculated_features[1,10] <- no_neigh_above(current_file) # works
calculated_features[1,11] <- no_neigh_below(current_file) # works
calculated_features[1,12] <- no_neigh_left(current_file) # works
calculated_features[1,13] <- no_neigh_right(current_file) # works
calculated_features[1,14] <- no_neigh_horiz(current_file) # works
calculated_features[1,15] <- no_neigh_vert(current_file) # works
#calculated_features[1,16] <- connected_areas(current_file)
#calculated_features[1,17] <- eyes(current_file)
#calculated_features[1,18] <- custome(current_file)
print(calculated_features[1,9])
}
}
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
plot(clump1)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
print(clump1.values)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
?raster
freq(rc)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
?clump
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
View(clump1)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
View(rast1)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
warnings()
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
{
library(readr)
library(utile.tables)
library(raster)
library(igraph)
# creating a list of all the files in the data_set
folder_path <- "dataset/csv_images_dataset"
data_folder <- list.files(path = folder_path)
# updating the file path string so it can be used later
folder_path <- paste(folder_path, "/", sep="")
# program functions
# These are the functions for calculating each of the features the dataset files
# function returns the label for the current_file passed in parameters
getFileLabel <- function(current_file_name){
file_name <- current_file_name
file_name_split <- strsplit(file_name, "_")
file_names_split_matrix <- matrix(unlist(file_name_split), nrow = 1, byrow = TRUE)
label <- file_names_split_matrix[1,2]
return(label)
}
# gets the current files index from the file name
getIndex <- function(current_file_name){
file_name <- current_file_name
file_name_split <- strsplit(file_name, "_")
file_name_split_matrix <- matrix(unlist(file_name_split), nrow = 1, byrow = TRUE)
index_with_extension <- file_name_split_matrix[1,3]
index <- substr(index_with_extension, 1, 2)
return(index)
}
# return the number of black pixels in image
nr_pix <- function(current_file){
return(sum(current_file))
}
# counts the number of rows with 1
rows_with_1 <- function(current_file){
rows_greater_than_1_sum <- 0
row_sums<- c(rowSums(current_file))
for(current_index in 1:length(row_sums)){
if( row_sums[current_index] > 0 ){
rows_greater_than_1_sum <- rows_greater_than_1_sum + 1
}
}
return(rows_greater_than_1_sum)
}
cols_with_1 <- function(current_file){
cols_greater_than_1_sum <- 0
col_sums<- c(colSums(current_file))
for(current_index in 1:length(col_sums)){
if( col_sums[current_index] > 0 ){
cols_greater_than_1_sum <- cols_greater_than_1_sum + 1
}
}
return(cols_greater_than_1_sum)
}
# returns number of rows with 3 or more pixels from image
rows_with_3p <- function(current_file){
rows_greater_than_3_sum <- 0
row_sums<- c(rowSums(current_file))
for(current_index in 1:length(row_sums)){
if( row_sums[current_index] >= 3){
rows_greater_than_3_sum <- rows_greater_than_3_sum + 1
}
}
return(rows_greater_than_3_sum)
}
# returns number of columns with 3 or more pixels
cols_with_3p<- function(current_file){
cols_greater_than_3_sum <- 0
col_sums<- c(colSums(current_file))
for(current_index in 1:length(col_sums)){
if( col_sums[current_index] >= 3  ){
cols_greater_than_3_sum <- cols_greater_than_3_sum + 1
}
}
return(cols_greater_than_3_sum)
}
# this gets the aspect ratio width/height
# need to validate aspect ratios are correct a1 calculation and function does not seem to be right
aspect_ratio <- function(current_file){
# get the pixel distance between the top most black pixel and bottom
row_sum_matrix <- rowSums(current_file)
top_element <- 0
bottom_element <- 0
current_index <- 1
while(top_element == 0){
if(row_sum_matrix[current_index] > 0){
top_element <- current_index
break
}
current_index <- current_index + 1
}
# get the pixel index of the bottom most black pixel
current_index <- length(row_sum_matrix)
while(bottom_element == 0){
if(row_sum_matrix[current_index] > 0){
bottom_element <- current_index
break
}
current_index <- current_index - 1
}
height <- bottom_element - top_element
# getting the width
left_most_element <- 0
right_most_element <- 0
col_sum_matrix <- colSums(current_file)
current_index <- 1
while(left_most_element == 0){
if(col_sum_matrix[current_index] > 0){
left_most_element <- current_index
break
}
current_index <- current_index + 1
}
# get the pixel index of the bottom most black pixel
current_index <- length(col_sum_matrix)
while(right_most_element == 0){
if(col_sum_matrix[current_index] > 0){
right_most_element <- current_index
break
}
current_index <- current_index - 1
}
width <- right_most_element - left_most_element
return(width/height)
}
# This returns the number of black pixels with only 1 black pixel neighbour
neigh_1 <- function(current_file){
num_neighbours <- 0
for(row_index in 1:nrow(current_file)){
for(col_index in 1:ncol(current_file)){
if(current_file[row_index, col_index] == 1){
neighbours <- c(0,0,0,0,0,0,0,0)
names(neighbours) <- c("upper left", "upper", "upper right", "left", "right", "bottom left", "bottom", "bottom right")
# checking upper region
if(row_index > 1){
# upper
if(current_file[row_index - 1, col_index] == 1)
neighbours[2] <- 1
# upper left
if(col_index > 1){
if(current_file[row_index - 1, col_index -1] == 1)
neighbours[1] <- 1
}
# upper right
if(col_index < ncol(current_file)){
if(current_file[row_index - 1, col_index + 1] == 1)
neighbours[3] <- 1
}
}
# left
if(col_index > 1){
if(current_file[row_index, col_index - 1])
neighbours[4] <- 1
}
# right
if(col_index < ncol(current_file)){
if(current_file[row_index, col_index +1])
neighbours[5] <- 1
}
# checking the bottom region
if(row_index < nrow(current_file)){
# checking bottom
if(current_file[row_index + 1, col_index] == 1)
neighbours[7] <- 1
# bottom left
if(col_index > 1){
if(current_file[row_index + 1, col_index -1] == 1)
neighbours[6] <- 1
}
# bottom right
if(col_index < ncol(current_file)){
if(current_file[row_index + 1, col_index + 1] == 1)
neighbours[8] <- 1
}
}
if(sum(neighbours) == 1)
num_neighbours <- num_neighbours + 1
}
}
}
return(num_neighbours)
}
# number of black pixels wiTh no black pixel neighbours
# "upper left, upper, and "Upper right"
no_neigh_above <- function(current_file){
num_no_upper_neighbours <- 0
for(row_index in 1:nrow(current_file)){
for(col_index in 1:ncol(current_file)){
if(current_file[row_index, col_index] == 1){
neighbours <- c(0,0,0)
names(neighbours) <- c("upper left", "upper", "upper right")
# checking upper region
if(row_index > 1){
# upper
if(current_file[row_index - 1, col_index] == 1)
neighbours[2] <- 1
# upper left
if(col_index > 1){
if(current_file[row_index - 1, col_index -1] == 1)
neighbours[1] <- 1
}
# upper right
if(col_index < ncol(current_file)){
if(current_file[row_index - 1, col_index + 1] == 1)
neighbours[3] <- 1
}
}
if(sum(neighbours) == 0)
num_no_upper_neighbours <- num_no_upper_neighbours + 1
}
}
}
return(num_no_upper_neighbours)
}
# returns the number of black pixels that have no black
# pixel neighbours "below", "below right", or "below left"
no_neigh_below <- function(current_file){
num_no_lower_neighbours <- 0
for(row_index in 1:nrow(current_file)){
for(col_index in 1:ncol(current_file)){
if(current_file[row_index, col_index] == 1){
neighbours <- c(0,0,0)
names(neighbours) <- c("bottom left", "bottom", "bottom right")
# checking the bottom region
if(row_index < nrow(current_file)){
# checking bottom
if(current_file[row_index + 1, col_index] == 1)
neighbours[2] <- 1
# bottom left
if(col_index > 1){
if(current_file[row_index + 1, col_index -1] == 1)
neighbours[1] <- 1
}
# bottom right
if(col_index < ncol(current_file)){
if(current_file[row_index + 1, col_index + 1] == 1)
neighbours[3] <- 1
}
}
if(sum(neighbours) == 0)
num_no_lower_neighbours <- num_no_lower_neighbours + 1
}
}
}
return(num_no_lower_neighbours)
}
# returns number of pixels that have no black pixel neighbours
# on the left
no_neigh_left <- function(current_file){
num_no_left_neighbours <- 0
for(row_index in 1:nrow(current_file)){
for(col_index in 1:ncol(current_file)){
if(current_file[row_index, col_index] == 1){
neighbours <- c(0,0,0)
names(neighbours) <- c("upper left", "left", "bottom left")
# checking the left
if(col_index > 1){
# checking left
if(current_file[row_index, col_index - 1] == 1)
neighbours[2] <- 1
# bottom left
if(row_index < nrow(current_file)){
if(current_file[row_index + 1, col_index -1] == 1)
neighbours[3] <- 1
}
# top left
if(col_index < ncol(current_file)){
if(current_file[row_index - 1, col_index - 1] == 1)
neighbours[1] <- 1
}
}
if(sum(neighbours) == 0)
num_no_left_neighbours <- num_no_left_neighbours + 1
}
}
}
return(num_no_left_neighbours)
}
# returns number of pixels that have no black pixel neighbours
# on the right
no_neigh_right <- function(current_file){
num_no_right_neighbours <- 0
for(row_index in 1:nrow(current_file)){
for(col_index in 1:ncol(current_file)){
if(current_file[row_index, col_index] == 1){
neighbours <- c(0,0,0)
names(neighbours) <- c("upper right", "right", "bottom right")
# checking the right
if(col_index < ncol(current_file)){
# checking left
if(current_file[row_index, col_index + 1] == 1)
neighbours[2] <- 1
# bottom right
if(row_index < nrow(current_file)){
if(current_file[row_index + 1, col_index + 1] == 1)
neighbours[3] <- 1
}
# top right
if(col_index < ncol(current_file)){
if(current_file[row_index - 1, col_index + 1] == 1)
neighbours[1] <- 1
}
}
if(sum(neighbours) == 0)
num_no_right_neighbours <- num_no_right_neighbours + 1
}
}
}
return(num_no_right_neighbours)
}
# returns number of black pixels that have no
# black pixel neighbours right or left
no_neigh_horiz <- function(current_file){
num_no_horiz_neighbours <- 0
for(row_index in 1:nrow(current_file)){
for(col_index in 1:ncol(current_file)){
if(current_file[row_index, col_index] == 1){
neighbours <- c(0,0)
names(neighbours) <- c("left", "right")
# check left black pixel
# neighbour
if(col_index > 1){
if(current_file[row_index, col_index - 1])
neighbours[1] <- 1
}
if(col_index < ncol(current_file)){
if(current_file[row_index, col_index +1])
neighbours[2] <- 1
}
if(sum(neighbours) == 0)
num_no_horiz_neighbours <- num_no_horiz_neighbours + 1
}
}
}
return(num_no_horiz_neighbours)
}
# returns number of black pixels that have no
# black pixels neighbours upper or lower
no_neigh_vert <- function(current_file){
num_no_vert_neighbours <- 0
for(row_index in 1:nrow(current_file)){
for(col_index in 1:ncol(current_file)){
if(current_file[row_index, col_index] == 1){
neighbours <- c(0,0)
names(neighbours) <- c("above", "below")
# check pixels above
if(row_index < nrow(current_file)){
if(current_file[row_index + 1, col_index] == 1)
neighbours[1] <- 1
}
# check pixels below
if(row_index < nrow(current_file))
if(current_file[row_index - 1, col_index] == 1)
neighbours[2] <- 1
if(sum(neighbours) == 0)
num_no_vert_neighbours <- num_no_vert_neighbours + 1
}
}
}
return(num_no_vert_neighbours)
}
connected_areas <- function(current_file){
rast <- raster(current_file)
clump <- clump(rast1, directions=8)
return(maxValue(clump1))
}
eyes <- function(current_file){
}
# for custom I think I should check for enclosed area.
# this would allow me to distinguish between letters
# and exclude an image from being a smliey face or some of the
# letters
custom <- function(current_file){
}
for(current_index in 1:length(data_folder))
{
current_file_name <- data_folder[current_index]
current_file_path <- paste(folder_path, current_file_name, sep = "")
current_file <- as.matrix(read.table(file = current_file_path, header = F, sep = ","))
calculated_features = matrix(ncol = 18, nrow = 1)
colnames(calculated_features) <- c("Label", "Index", "nr_pix", "rows_with_1", "cols_with_1",
"rows_with_3p", "cols_with_3p", "aspect ratio", "neigh_1",
"no_neigh_above","no_neigh_below","no_neigh_left","no_neigh_right",
"no_neigh_horiz", "no_neigh_vert","connected_areas","eyes","custom")
calculated_features[1,1] <- getFileLabel(current_file_name) # works
calculated_features[1,2] <- getIndex(current_file_name) # works
calculated_features[1,3] <- nr_pix(current_file) # works
calculated_features[1,4] <- rows_with_1(current_file) # works
calculated_features[1,5] <- cols_with_1(current_file) # works
calculated_features[1,6] <- rows_with_3p(current_file) # works
calculated_features[1,7] <- cols_with_3p(current_file) # works
calculated_features[1,8] <- aspect_ratio(current_file) # works
calculated_features[1,9] <- neigh_1(current_file) # not working, needs testing
calculated_features[1,10] <- no_neigh_above(current_file) # works
calculated_features[1,11] <- no_neigh_below(current_file) # works
calculated_features[1,12] <- no_neigh_left(current_file) # works
calculated_features[1,13] <- no_neigh_right(current_file) # works
calculated_features[1,14] <- no_neigh_horiz(current_file) # works
calculated_features[1,15] <- no_neigh_vert(current_file) # works
calculated_features[1,16] <- connected_areas(current_file)
#calculated_features[1,17] <- eyes(current_file)
#calculated_features[1,18] <- custome(current_file)
#print(calculated_features[1,9])
}
}
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
source("~/ai-project/Feature engineering calculations script.R", echo=TRUE)
